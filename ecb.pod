=head1 LIBECB - e-C-Builtins

=head2 ABOUT LIBECB

Libecb is currently a simple header file that doesn't require any
configuration to use or include in your project.

It's part of the e-suite of libraries, other members of which include
libev and libeio.

Its homepage can be found here:

    http://software.schmorp.de/pkg/libecb

It mainly provides a number of wrappers around many compiler built-ins,
together with replacement functions for other compilers. In addition
to this, it provides a number of other lowlevel C utilities, such as
endianness detection, byte swapping or bit rotations.

Or in other words, things that should be built into any standard C
system, but aren't, implemented as efficient as possible with GCC (clang,
msvc...), and still correct with other compilers.

More might come.

Libecb目前是一个简单的头文件，可以在不需要任何配置的情况下加入到你自己的项目中。

它是整个套件的一部分，其他成员包括libev libeio。

主页可在此找到(但是这个网址已经失效了,可惜):
http://software.schmorp.de/pkg/libecb

它主要为许多内置编译器提供了许多包装器，以及其他编译器的替换函数。
除此之外，它还提供了许多其他比较底层的C实用程序，如字节交换或位旋转。

或者换句话说，libecb可以被引入到任何标准C开发的系统中，
它可以保证不同编译器中的通用性.

更多的可能。

=head2 ABOUT THE HEADER

At the moment, all you have to do is copy F<ecb.h> somewhere where your
compiler can find it and include it:

   #include <ecb.h>

The header should work fine for both C and C++ compilation, and gives you
all of F<inttypes.h> in addition to the ECB symbols.

There are currently no object files to link to - future versions might
come with an (optional) object code library to link against, to reduce
code size or gain access to additional features.

It also currently includes everything from F<inttypes.h>.

现在，你所要做的就是复制F<ecb.h>,放入你的项目.编译器可以找到它并包含它:

#include < ecb.h >

头文件对于C和c++编译都可以很好地工作，并为您提供除了ECB符号外，所有的F<inttypes.h>。

目前没有.o文件需要被link,未来的版本可能会提供可选的.o文件,
以用来减少代码的大小和增加额外的功能.

它目前还包括从F<inttypes.h>开始的所有内容。

=head2 ABOUT THIS MANUAL / CONVENTIONS

This manual mainly describes each (public) function available after
including the F<ecb.h> header. The header might define other symbols than
these, but these are not part of the public API, and not supported in any
way.

When the manual mentions a "function" then this could be defined either as
as inline function, a macro, or an external symbol.

When functions use a concrete standard type, such as C<int> or
C<uint32_t>, then the corresponding function works only with that type. If
only a generic name is used (C<expr>, C<cond>, C<value> and so on), then
the corresponding function relies on C to implement the correct types, and
is usually implemented as a macro. Specifically, a "bool" in this manual
refers to any kind of boolean value, not a specific type.

本手册主要描述了F<ecb.h>头文件内可用的每个(公共)函数.
头文件可以定义其他符号,但那些都不是公共API的一部分，也不会有任何的支持.

当手册提到一个“函数”时，它可以一个内联函数、一个宏定义或外部符号。

当函数使用具体的标准类型时，例如C<int>或C<uint32_t>，则相应的函数只适用于该类型。
如果只使用通用名称(C<expr>， C<cond>， C<value>，等等)，那么对应的函数依赖于C语言来实现正确的类型，并且通常作为宏实现。
具体地说，是本手册中的“bool”指任何类型的布尔值，而不是特定类型。

=head2 TYPES / TYPE SUPPORT

ecb.h makes sure that the following types are defined (in the expected way):

ecb.h确保以下类型被定义(以预期的方式):  

   int8_t       uint8_
   int16_t      uint16_t
   int32_t      uint32_
   int64_t      uint64_t
   int_fast8_t  uint_fast8_t
   int_fast16_t uint_fast16_t
   int_fast32_t uint_fast32_t
   int_fast64_t uint_fast64_t
   intptr_t     uintptr_t

The macro C<ECB_PTRSIZE> is defined to the size of a pointer on this
platform (currently C<4> or C<8>) and can be used in preprocessor
expressions.

For C<ptrdiff_t> and C<size_t> use C<stddef.h>/C<cstddef>.

宏C<ECB_PTRSIZE>定义为目标平台上的指针的大小(目前C<4>或C<8>),可以用于预处理器表达式。

而C<ptrdiff_t>和C<size_t>使用的C<stddef.h>/C<cstddef>中的定义.

=head2 LANGUAGE/ENVIRONMENT/COMPILER VERSIONS

All the following symbols expand to an expression that can be tested in
preprocessor instructions as well as treated as a boolean (use C<!!> to
ensure it's either C<0> or C<1> if you need that).

下面的符号都可以在预处理器指令中被展开且可以被作为一个bool值而被测试(如果你需要的话,使用C<!!>确保它是C<0>或C<1>).

=over

=item ECB_C

True if the implementation defines the C<__STDC__> macro to a true value,
while not claiming to be C++, i..e C, but not C++.

当该值为true,则表示当前实现定义了C<__STDC__>宏定义.仅仅是c,不是cxx.
PS:当前的版本好像去掉了这个宏,因为没找到.

=item ECB_C99

True if the implementation claims to be compliant to C99 (ISO/IEC
9899:1999) or any later version, while not claiming to be C++.

Note that later versions (ECB_C11) remove core features again (for
example, variable length arrays).

当该值为True,这表示当前实现声称符合C99 (ISO/IEC9999:1999)或任何更新的版本，而不是声称是c++。
请注意，新版本(ECB_C11)会再次删除核心特性(例如可变长度数组)。

=item ECB_C11, ECB_C17

True if the implementation claims to be compliant to C11/C17 (ISO/IEC
9899:2011, :20187) or any later version, while not claiming to be C++.

当该值为True,这表示当前实现声称符合ECB_C11, ECB_C17 (ISO/IEC9899:2011, :20187)或任何更新的版本，而不是声称是c++。

=item ECB_CPP

True if the implementation defines the C<__cplusplus__> macro to a true
value, which is typically true for C++ compilers.

当该值为True,则表示定义的宏 C<__cplusplus__>为True.
这是一个典型的对于c++编译器的真值.

=item ECB_CPP11, ECB_CPP14, ECB_CPP17

True if the implementation claims to be compliant to C++11/C++14/C++17
(ISO/IEC 14882:2011, :2014, :2017) or any later version.

Note that many C++20 features will likely have their own feature test
macros (see e.g. L<http://eel.is/c++draft/cpp.predefined#1.8>).

当该值为True,则表示当前实现符合C++11/C++14/C++17(ISO/IEC 14882:2011, :2014, :2017)或任何更新的版本.
请注意，c++ 20的许多特性可能都有自己的特性测试(参见L<http://eel.is/c++draft/cpp.predefined#1.8>)。

=item ECB_OPTIMIZE_SIZE

Is C<1> when the compiler optimizes for size, C<0> otherwise. This symbol
can also be defined before including F<ecb.h>, in which case it will be
unchanged.

当编译器优化大小时为C<1>，否则为C<0>。
这个符号也可以在包含F<ecb.h>之前定义，那么该值将会是定义的值,而不会改变。

=item ECB_GCC_VERSION (major, minor)

Expands to a true value (suitable for testing by the preprocessor) if the
compiler used is GNU C and the version is the given version, or higher.

This macro tries to return false on compilers that claim to be GCC
compatible but aren't.

如果编译器使用的是指定版本或者更改版本的GNU C编译器,则该值为True.

当认为编译器为GCC但是它不是的时候,则返回False.

=item ECB_EXTERN_C

Expands to C<extern "C"> in C++, and a simple C<extern> in C.

This can be used to declare a single external C function:

   ECB_EXTERN_C int printf (const char *format, ...);

该值在c++中扩展为C<extern "C">，在C中扩展为简单的C<extern>。

这可以用来声明一个单独的外部C函数:
ECB_EXTERN_C int printf (const char *format，…);

=item ECB_EXTERN_C_BEG / ECB_EXTERN_C_END

These two macros can be used to wrap multiple C<extern "C"> definitions -
they expand to nothing in C

这两个宏可以用来包装多个 C<extern "C"> 的定义-在C里面不会有任何的效果

They are most useful in header files:
它们在头文件中多数被这样使用:

   ECB_EXTERN_C_BEG

   int mycfun1 (int x);
   int mycfun2 (int x);

   ECB_EXTERN_C_END

=item ECB_STDFP

If this evaluates to a true value (suitable for testing by the
preprocessor), then C<float> and C<double> use IEEE 754 single/binary32
and double/binary64 representations internally I<and> the endianness of
both types match the endianness of C<uint32_t> and C<uint64_t>.

This means you can just copy the bits of a C<float> (or C<double>) to an
C<uint32_t> (or C<uint64_t>) and get the raw IEEE 754 bit representation
without having to think about format or endianness.

This is true for basically all modern platforms, although F<ecb.h> might
not be able to deduce this correctly everywhere and might err on the safe
side.

如果此值计算为真(可用于预处理器做判断),那么C<float>和C<double>
使用IEEE 754 single/binary32和double/binary64表示.
内部两者的字节序和C<uint32_t>与C<uint64_t>的字节序相同.

这意味着您可以将C<float>(或C<double>)的位复制到C<uint32_t>(或C<uint64_t>)，
得到原始的IEEE 754位表示而无需考虑格式或字节序。

这对于所有现代的平台都是正确的，虽然F<ecb.h>可能无法在任何地方正确地推导出这点，而且可能会在安全方面出错。

PS:也就是说int和float两者之间可以转换,但是没有办法证明一定正确,但现实就是很多都是这么使用的.如何转换,是一个C的hack,自己想一下??

=item ECB_64BIT_NATIVE

Evaluates to a true value (suitable for both preprocessor and C code
testing) if 64 bit integer types on this architecture are evaluated
"natively", that is, with similar speeds as 32 bit integers. While 64 bit
integer support is very common (and in fact required by libecb), 32 bit
cpus have to emulate operations on them, so you might want to avoid them.
如果计算结果为真(该值也可用于预处理器和C代码的测试),那么该体系结构对于64位的支持是内置的.
也就是说,速度上64位和32位整数是差不对哦的,虽然64位支持非常常见(实际上libecb也需要),
但32位的cpu必须模拟64位的操作,所以你可能希望避免它们.
PS:libecb的年代64位还没那么普及??

=item ECB_AMD64, ECB_AMD64_X32

These two macros are defined to C<1> on the x86_64/amd64 ABI and the X32
ABI, respectively, and undefined elsewhere.

The designers of the new X32 ABI for some inexplicable reason decided to
make it look exactly like amd64, even though it's completely incompatible
to that ABI, breaking about every piece of software that assumed that
C<__x86_64> stands for, well, the x86-64 ABI, making these macros
necessary.

这两个宏在x86_64/amd64 ABI和X32 ABI上分别定义为C<1>，在其他地方未定义。

新的X32 ABI的设计者出于某种无法解释的原因，决定让它看起来像amd64的一模一样.
尽管它与那个ABI完全不兼容，这打破了假定C<__x86_64>表示x86-64 ABI，所以使得这些宏是必要的。

=back

=head2 MACRO TRICKERY

=over

=item ECB_CONCAT (a, b)

Expands any macros in C<a> and C<b>, then concatenates the result to form
a single token. This is mainly useful to form identifiers from components,

展开C<a>和C<b>中的任何宏，然后将结果连接起来形成单个标记。这主要用于从组件中形成标识符，

e.g.:

   #define S1 str
   #define S2 cpy

   ECB_CONCAT (S1, S2)(s1, s2); // == strcpy (s1, s2);

=item ECB_STRINGIFY (arg)

Expands any macros in C<arg> and returns the stringified version of
it. This is mainly useful to get the contents of a macro in string form,

展开C<arg>中的任何宏并返回它的字符串化版本。这主要用于以字符串形式获取宏的内容，

e.g.:

   #define SQL_LIMIT 100
   sql_exec ("select * from table limit " ECB_STRINGIFY (SQL_LIMIT));

=item ECB_STRINGIFY_EXPR (expr)

Like C<ECB_STRINGIFY>, but additionally evaluates C<expr> to make sure it
is a valid expression. This is useful to catch typos or cases where the
macro isn't available:

类似于C<ECB_STRINGIFY>，但是会先计算一次C<expr>以确保它是一个有效的表达式。
(PS:所以,这里会有一个宏定义常有的,expr被多次计算的问题)
这对于捕捉输入错误或宏不可用的情况很有用:

   #include <errno.h>

   ECB_STRINGIFY      (EDOM); // "33" (on my system at least)
   ECB_STRINGIFY_EXPR (EDOM); // "33"

   // now imagine we had a typo:
   //现在假设我们有一个打印错误

   ECB_STRINGIFY      (EDAM); // "EDAM" 这样的话直接就是输出
   ECB_STRINGIFY_EXPR (EDAM); // error: EDAM undefined,第一次计算发现EDAM没有被定义,所以直接报错

=back

=head2 ATTRIBUTES

A major part of libecb deals with additional attributes that can be
assigned to functions, variables and sometimes even types - much like
C<const> or C<volatile> in C. They are implemented using either GCC
attributes or other compiler/language specific features. Attributes
declarations must be put before the whole declaration:

libecb的大部分的附加属性可以用于函数、变量的处理，有时甚至是一些类型的附加属性,像C中的C<const>或C<volatile>。
它们是使用GCC属性或其他编译器/语言特定特性实现的。属性声明必须放在整个声明之前:

   ECB_CONST int mysqrt (int a);
   ecb_unused int i;

=over

=item ecb_unused

Marks a function or a variable as "unused", which simply suppresses a
warning by the compiler when it detects it as unused. This is useful when
you e.g. declare a variable but do not always use it:

将函数或变量标记为“未使用”，这只会在编译器检测到它未使用时，简单地抑制编译器的警告。
当你声明一个变量但不总是使用它时，这是很有用的:

  {
    ecb_unused int var;

    #ifdef SOMECONDITION
       var = ...;
       return var;
    #else
       return 0;
    #endif
  }

=item ecb_deprecated

Similar to C<ecb_unused>, but marks a function, variable or type as
deprecated. This makes some compilers warn when the type is used.

类似于C<ecb_unused>，此标记讲函数、变量或类型标记为弃用。
这使得一些编译器在使用该类型时发出警告。

=item ecb_deprecated_message (message)

Same as C<ecb_deprecated>, but if possible, the specified diagnostic is
used instead of a generic depreciation message when the object is being
used.

与C<ecb_deprecated>相同，但如果可能，在使用对象时使用指定的诊断信息，而不是通用的报错消息。

=item ECB_INLINE

Expands either to (a compiler-specific equivalent of) C<static inline> or
to just C<static>, if inline isn't supported. It should be used to declare
functions that should be inlined, for code size or speed reasons.

扩展为C<static inline>,或者如果不支持内联，仅仅扩展为C<static>(编译器特定的等效)。
由于代码大小或速度的原因，它应该仅仅用于声明应该内联的函数。

Example: inline this function, it surely will reduce codesize.
示例:内联这个函数，它肯定会减少代码。

   ECB_INLINE int
   negmul (int a, int b)
   {
     return - (a * b);
   }

=item ecb_noinline

Prevents a function from being inlined - it might be optimised away, but
not inlined into other functions. This is useful if you know your function
is rarely called and large enough for inlining not to be helpful.

防止函数内联——它可能会被优化掉，但不会内联到其他函数中。
如果您知道您的函数很少被调用，并且足够大以至于内联不会有帮助，那么这个宏定义是很有用的。

=item ecb_noreturn

Marks a function as "not returning, ever". Some typical functions that
don't return are C<exit> or C<abort> (which really works hard to not
return), and now you can make your own:

将函数标记为“永远不返回”。
一些永不返回的典型函数像是C<exit>或C<abort>(这些函数确实很难做到不返回)，
现在你可以创建自己类似的函数:

   ecb_noreturn void
   my_abort (const char *errline)
   {
     puts (errline);
     abort ();
   }

In this case, the compiler would probably be smart enough to deduce it on
its own, so this is mainly useful for declarations.

在这种情况下，编译器足够聪明的话能够自行推导出它，所以这主要用于声明。

=item ecb_restrict

Expands to the C<restrict> keyword or equivalent on compilers that support
them, and to nothing on others. Must be specified on a pointer type or
an array index to indicate that the memory doesn't alias with any other
restricted pointer in the same scope.

在支持的编译器上扩展为C<restrict>关键字或等效值，而在其他编译器上则没有扩展为任何值。
必须在指针类型或数组索引上指定，以指示内存没有与同一作用域中的任何其他受限制的指针别名。
PS: 参考restrict关键字:restrict是c99标准引入的，它只可以用于限定和约束指针，
    并表明指针是访问一个数据对象的唯一且初始的方式.
    即它告诉编译器，所有修改该指针所指向内存中内容的操作都必须通过该指针来修改,
    而不能通过其它途径(其它变量或指针)来修改;这样做的好处是,能帮助编译器进行更好的优化代码,生成更有效率的汇编代码.
    也就是说在restrict关键字形容的变量的相同的访问内,不允许出现restrict修饰指针或者数组的别名.

Example: multiply a vector, and allow the compiler to parallelise the
loop, because it knows it doesn't overwrite input values.

例如:将一个向量乘起来，并允许编译器并行化循环，因为编译器知道它不会覆盖输入的值。

   void
   multiply (ecb_restrict float *src,
             ecb_restrict float *dst,
             int len, float factor)
   {
     int i;

     for (i = 0; i < len; ++i)
       dst [i] = src [i] * factor;
   }

=item ECB_CONST

Declares that the function only depends on the values of its arguments,
much like a mathematical function. It specifically does not read or write
any memory any arguments might point to, global variables, or call any
non-const functions. It also must not have any side effects.

Such a function can be optimised much more aggressively by the compiler -
for example, multiple calls with the same arguments can be optimised into
a single call, which wouldn't be possible if the compiler would have to
expect any side effects.

It is best suited for functions in the sense of mathematical functions,
such as a function returning the square root of its input argument.

Not suited would be a function that calculates the hash of some memory
area you pass in, prints some messages or looks at a global variable to
decide on rounding.

See C<ecb_pure> for a slightly less restrictive class of functions.

声明函数只依赖于其实参的值，就像数学函数。它特殊之处在于不读取或写入任何参数可能指向的内存、全局变量或调用任何非const函数。它也也会有任何的副作用。

这样的函数可以由编译器更好地优化——例如，具有相同参数的多个调用可以优化为一个调用，如果编译器预设该调用具有任何副作用，那么这种优化是不可能的。

它最适合于数学函数意义上的函数，例如返回其输入参数平方根的函数。

不适合使用计算传入内存区域的哈希值、打印一些消息或查看全局变量来决定舍入的函数。

请参阅C<ecb_pure>了解限制稍少的函数类。

PS:
用const属性修饰的函数与用pure属性修饰的十分类似，不过const属性比pure更严格.
它要求函数不能读全局对象。
此外，用const属性修饰的函数的参数不能是一个指针类型，而且在用const属性修饰的函数内往往不能调用一个非const属性的函数。

=item ecb_pure

Similar to C<ECB_CONST>, declares a function that has no side
effects. Unlike C<ECB_CONST>, the function is allowed to examine global
variables and any other memory areas (such as the ones passed to it via
pointers).

While these functions cannot be optimised as aggressively as C<ECB_CONST>
functions, they can still be optimised away in many occasions, and the
compiler has more freedom in moving calls to them around.

Typical examples for such functions would be C<strlen> or C<memcmp>. A
function that calculates the MD5 sum of some input and updates some MD5
state passed as argument would I<NOT> be pure, however, as it would modify
some memory area that is not the return value.

类似于C<ECB_CONST>，声明一个没有副作用的函数。与C<ECB_CONST>不同，
该函数允许检查全局变量和任何其他内存区域(比如通过指针传递给它的内存区域)。

虽然这些函数不能像C<ECB_CONST>函数那样被更好地优化，但在很多情况下，
它们仍然可以被优化掉，而且编译器可以更自由地将调用转移到它们那里。

这类函数的典型例子是C<strlen>或C<memcmp>。函数计算输入的MD5并且作为参数传递更新MD5的状态,
这些函数不是pure的,因为这些函数将修改一些不是返回值的内存区域.

PS:
用pure属性修饰的函数用来说明该函数除了返回值之外没有其他任何效果，
并且该函数所返回的值仅仅依赖于函数的形参以及/或全局对象。
用 pure属性所修饰的函数可以用来辅助编译器做消除公共子表达式以及帮助做循环优化，使用这种函数就好比使用算术操作符一般。

用pure属性所修饰的函数体内不应该含有无限循环，不应该对volatile修饰的全局对象进行访问或是对多个线程所共享的全局对象进行访问，
也 不应该访问其他系统资源，比如对文件、套接字等进行操作。
简而言之， 对同一个使用pure属性修饰的函数连续做两次调用（如果该函数带有参 数，那么两次调用应该用同样的实参），
那么这两次调用所返回的结果应 该始终是相同的。因此，用pure属性所修饰的函数也很容易让编译器做内 联处理。

=item ecb_hot

This declares a function as "hot" with regards to the cache - the function
is used so often, that it is very beneficial to keep it in the cache if
possible.

The compiler reacts by trying to place hot functions near to each other in
memory.

Whether a function is hot or not often depends on the whole program,
and less on the function itself. C<ecb_cold> is likely more useful in
practise.


这是声明函数对于缓存是“hot”函数,也就是说此函数使用频繁.如果可能的话,将它保持在缓存中是非常有用的.

编译器的做法是试图将热函数彼此靠近保存在内存里。

一个函数是否热通常取决于整个程序，函数本身的作用更小。实践中C<ecb_cold>可能更有用。

PS:是不是就是说,将函数直接保存在内存中,减少加载的时间?

=item ecb_cold

The opposite of C<ecb_hot> - declares a function as "cold" with regards to
the cache, or in other words, this function is not called often, or not at
speed-critical times, and keeping it in the cache might be a waste of said
cache.

In addition to placing cold functions together (or at least away from hot
functions), this knowledge can be used in other ways, for example, the
function will be optimised for size, as opposed to speed, and codepaths
leading to calls to those functions can automatically be marked as if
C<ecb_expect_false> had been used to reach them.

Good examples for such functions would be error reporting functions, or
functions only called in exceptional or rare cases.

与C<ecb_hot>相反的是，声明一个函数对于缓存来说是“冷的”.
或者换句话说，这个函数不经常被调用，或者不是在临界速度的时候调用，将它保存在缓存中可能是对缓存的浪费。

除了一起放置冷功能(或者至少远离热功能),这些知识可以用在其他方面.
例如,函数将优化函数大小,而不是速度.导致调用这些函数的代码路径可以自动标记为C<ecb_expect_false>，就像已经使用C<ecb_expect_false>访问它们一样。

这类函数的好例子是错误报告函数，或者仅在异常或罕见情况下调用的函数。

=item ecb_artificial

Declares the function as "artificial", in this case meaning that this
function is not really meant to be a function, but more like an accessor
- many methods in C++ classes are mere accessor functions, and having a
crash reported in such a method, or single-stepping through them, is not
usually so helpful, especially when it's inlined to just a few instructions.

Marking them as artificial will instruct the debugger about just this,
leading to happier debugging and thus happier lives.

Example: in some kind of smart-pointer class, mark the pointer accessor as
artificial, so that the whole class acts more like a pointer and less like
some C++ abstraction monster.

声明函数是“artificial”的,在这种情况下,也就是说,这个函数并不意味着是一个函数,
更像一个访问器——许多方法在C++类中仅仅是访问器的功能,具有和崩溃报告同样的方法,或单步通过他们.
通常不是那么有用,特别是当它只内联到几个指令的时候。

将它们标记为artificial将指导调试器了解这一点，从而使调试工作更愉快，从而使生活更愉快。

例如:在某种智能指针类中，将指针访问器标记为人工的，这样整个类的行为就更像一个指针，而不像某个c++抽象怪物。

  template<typename T>
  struct my_smart_ptr
  {
    T *value;

    ecb_artificial
    operator T *()
    {
      return value;
    }
  };

=back

=head2 OPTIMISATION HINTS

=over

=item bool ecb_is_constant (expr)

Returns true iff the expression can be deduced to be a compile-time
constant, and false otherwise.

如果表达式被推断为编译时常量，则返回true，否则返回false。

For example, when you have a C<rndm16> function that returns a 16 bit
random number, and you have a function that maps this to a range from
0..n-1, then you could use this inline function in a header file:

例如，当您有一个返回16位随机数的C<rndm16>函数，并且您有一个函数将其映射到从0开始到N-1的范围，那么你可以在头文件中使用这个内联函数:

  ECB_INLINE uint32_t
  rndm (uint32_t n)
  {
    return (n * (uint32_t)rndm16 ()) >> 16;
  }

However, for powers of two, you could use a normal mask, but that is only
worth it if, at compile time, you can detect this case. This is the case
when the passed number is a constant and also a power of two (C<n & (n -
1) == 0>):

但是，对于2的幂，您可以使用普通掩码，不过只有在编译时检测到这种情况才可以这样做。
这是当传递的数字是一个常数，也是2的幂(C<n & (n -1) == 0>)的情况:

  ECB_INLINE uint32_t
  rndm (uint32_t n)
  {
    return is_constant (n) && !(n & (n - 1))
      ? rndm16 () & (num - 1)
      : (n * (uint32_t)rndm16 ()) >> 16;
  }

=item ecb_expect (expr, value)

Evaluates C<expr> and returns it. In addition, it tells the compiler that
the C<expr> evaluates to C<value> a lot, which can be used for static
branch optimisations.

Usually, you want to use the more intuitive C<ecb_expect_true> and
C<ecb_expect_false> functions instead.

计算C<expr>并返回它。此外，它告诉编译器C<expr>的计算结果很多都是C<value>，这可以用于静态分支优化。

通常，您希望使用更直观的C<ecb_expect_true>和C<ecb_expect_false>函数。

=item bool ecb_expect_true (cond)

=item bool ecb_expect_false (cond)

These two functions expect a expression that is true or false and return
C<1> or C<0>, respectively, so when used in the condition of an C<if> or
other conditional statement, it will not change the program:

这两个函数期望表达式为true或false，并分别返回C<1>或C<0>.
因此当用于C<if>或其他条件语句的条件时，它不会改变程序:

  /* these two do the same thing */
  if (some_condition) ...;
  if (ecb_expect_true (some_condition)) ...;

However, by using C<ecb_expect_true>, you tell the compiler that the
condition is likely to be true (and for C<ecb_expect_false>, that it is
unlikely to be true).

但是，通过使用C<ecb_expect_true>，您可以告诉编译器该条件大概率可能为真(对于C<ecb_expect_false>，它大概率为假)。

For example, when you check for a null pointer and expect this to be a
rare, exceptional, case, then use C<ecb_expect_false>:

例如，当你检查一个空指针，并期望它是一个罕见的，异常的，大小写，然后使用C<ecb_expect_false>:

  void my_free (void *ptr)
  {
    if (ecb_expect_false (ptr == 0))
      return;
  }

Consequent use of these functions to mark away exceptional cases or to
tell the compiler what the hot path through a function is can increase
performance considerably.

随后使用这些函数来标记异常情况，或者告诉编译器函数的热路径是什么，可以大大提高性能。

You might know these functions under the name C<likely> and C<unlikely>
- while these are common aliases, we find that the expect name is easier
to understand when quickly skimming code. If you wish, you can use
C<ecb_likely> instead of C<ecb_expect_true> and C<ecb_unlikely> instead of
C<ecb_expect_false> - these are simply aliases.

您可能知道名称为C<likely>和C<unlikely>的这些函数——尽管它们是常见的别名，
但我们发现，在快速浏览代码时，期望名称更容易理解。
如果您愿意，可以使用C<ecb_likely>而不是C<ecb_expect_true>和C<ecb_unlikely>而不是C<ecb_expect_false>—这些只是别名。

A very good example is in a function that reserves more space for some
memory block (for example, inside an implementation of a string stream) -
each time something is added, you have to check for a buffer overrun, but
you expect that most checks will turn out to be false:

一个很好的例子是:在函数中,会预分配更多一些的内存来存储某些东西(例如,一个字符串流)
  ——那么每次添加东西的时候,你必须检查缓冲区溢出,但你认为大多数情况下,预分配的对于空间是够用的:

  /* make sure we have "size" extra room in our buffer */
  ECB_INLINE void
  reserve (int size)
  {
    if (ecb_expect_false (current + size > end))
      real_reserve_method (size); /* presumably noinline */
  }

=item ecb_assume (cond)

Tries to tell the compiler that some condition is true, even if it's not
obvious. This is not a function, but a statement: it cannot be used in
another expression.

试图告诉编译器cond为真，即使它并不明显。这不是一个函数，而是一个语句:它不能被当做表达式使用。
PS:也就是说,它不能被放在if中做判断

This can be used to teach the compiler about invariants or other
conditions that might improve code generation, but which are impossible to
deduce form the code itself.

这可以用来告诉编译器关于不变量或其他可能改善代码生成的条件，但不可能从代码本身推断出来。

For example, the example reservation function from the C<ecb_expect_false>
description could be written thus (only C<ecb_assume> was added):

例如，C<ecb_expect_false>描述中的示例保留函数可以这样写(只添加了C<ecb_assume>):

  ECB_INLINE void
  reserve (int size)
  {
    if (ecb_expect_false (current + size > end))
      real_reserve_method (size); /* presumably noinline */

    ecb_assume (current + size <= end);
  }

If you then call this function twice, like this:
如果你调用这个函数2次,就像这样:

  reserve (10);
  reserve (1);

Then the compiler I<might> be able to optimise out the second call
completely, as it knows that C<< current + 1 > end >> is false and the
call will never be executed.

然后编译器I<可能>能够完全优化第二个调用，因为它知道C<< current + 1 > end >>是假的，调用将永远不会被执行。

=item ecb_unreachable ()

This function does nothing itself, except tell the compiler that it will
never be executed. Apart from suppressing a warning in some cases, this
function can be used to implement C<ecb_assume> or similar functionality.

这个函数本身什么都不做，除了告诉编译器它永远不会被执行。
除了在某些情况下不触发警告外，这个函数还可以用于实现C<ecb_assume>或类似的功能。

=item ecb_prefetch (addr, rw, locality)

Tells the compiler to try to prefetch memory at the given C<addr>ess
for either reading (C<rw> = 0) or writing (C<rw> = 1). A C<locality> of
C<0> means that there will only be one access later, C<3> means that
the data will likely be accessed very often, and values in between mean
something... in between. The memory pointed to by the address does not
need to be accessible (it could be a null pointer for example), but C<rw>
and C<locality> must be compile-time constants.

告诉编译器预加载数据到内存C<addr>ess为后续的读(C<rw> = 0)或写(C<rw> = 1)做准备。
C<locality> C<0>意味着只有一次访问,C<3>意味着可能是会经常访问的数据,并且数据准备的彼此之间……在两者之间。
addr所指向的内存不需要是可访问的(例如，它可以是一个空指针)，但是C<rw>和C<locality>必须是编译时常量。

This is a statement, not a function: you cannot use it as part of an
expression.

这是一个语句，而不是一个函数:你不能将它用作表达式的一部分。

An obvious way to use this is to prefetch some data far away, in a big
array you loop over. This prefetches memory some 128 array elements later,
in the hope that it will be ready when the CPU arrives at that location.

一种明显的方法是在一个大数组中，在较远的地方预加载一些数据。
这将在之后预加载内存中的128个数组元素，希望当CPU到达这个位置时，这些元素就已经准备好了。

  int sum = 0;

  for (i = 0; i < N; ++i)
    {
      sum += arr [i]
      ecb_prefetch (arr + i + 128, 0, 0);
    }

It's hard to predict how far to prefetch, and most CPUs that can prefetch
are often good enough to predict this kind of behaviour themselves. It
gets more interesting with linked lists, especially when you do some fair
processing on each list element:

一般很难预测预取的深度，但大多数CPU通常都能很好地预测这种行为。使用链表会变得更有趣，特别是当你对每个列表元素进行公平处理时:

  for (node *n = start; n; n = n->next)
    {
      ecb_prefetch (n->next, 0, 0);
      ... do medium amount of work with *n
    }

After processing the node, (part of) the next node might already be in
cache.

处理该节点后，下一个节点(部分)可能已经在缓存中.

PS:
  通过对数据手工预取的方法，减少了读取延迟，从而提高了性能，但该函数也需要 CPU 的支持。
  其中参数 addr 是个内存指针，它指向要预取的数据，我们人工需要判定这些数据是很快能访问到的，
  或者说是它们就在最近的内存中 --- 一般来说，对于链表而言，各个节点在内存中基本上是紧挨着的，所以我们容易预取链表节点里的指针项。

  该函数还有两个可选参数，rw 和 locality 。rw 是个编译时的常数，或 1 或 0 。1 时表示写(w)，0 时表示读(r) 。

  locality 必须是编译时的常数，也称为“时间局部性”(temporal locality) 。
  时间局部性是指，如果程序中某一条指令一旦执行，则不久之后该指令可能再被执行；
  如果某数据被访问，则不久之后该数据会被再次访问。该值的范围在 0 - 3 之间。为 0 时表示，它没有时间局部性，
  也就是说，要访问的数据或地址被访问之后的不长的时间里不会再被访问；
  为 3 时表示，被访问的数据或地址具有高 时间局部性，也就是说，在被访问不久之后非常有可能再次访问；
  对于值 1 和 2，则分别表示具有低 时间局部性 和中等 时间局部性。该值默认为 3 。

=back

=head2 BIT FIDDLING / BIT WIZARDRY

=over

=item bool ecb_big_endian ()

=item bool ecb_little_endian ()

These two functions return true if the byte order is big endian
(most-significant byte first) or little endian (least-significant byte
first) respectively.

On systems that are neither, their return values are unspecified.

当字节序为大端序(最高有效字节优先)时,ecb_big_endian返回true,反之(最低有效字节优先),ecb_little_endian返回true

在两者都不存在的系统上，它们的返回值是未指定的。

=item int ecb_ctz32 (uint32_t x)

=item int ecb_ctz64 (uint64_t x)

=item int ecb_ctz (T x) [C++]

Returns the index of the least significant bit set in C<x> (or
equivalently the number of bits set to 0 before the least significant bit
set), starting from 0. If C<x> is 0 the result is undefined.

For smaller types than C<uint32_t> you can safely use C<ecb_ctz32>.

The overloaded C++ C<ecb_ctz> function supports C<uint8_t>, C<uint16_t>,
C<uint32_t> and C<uint64_t> types.

返回C<x>中bit集中的最低有效位的索引(或相当于在bit集中最低有效位之前bit值为0的位数)，从0开始。如果C<x>是0，结果是没有定义的。

对于小于C<uint32_t>的类型，你可以安全地使用C<ecb_ctz32>。

重载的c++C<ecb_ctz>函数支持C<uint8_t>， C<uint16_t>， C<uint32_t>和C<uint64_t>类型。

For example:

  ecb_ctz32 (3) = 0 // bit:0000 0011 所以最小有效位是0
  ecb_ctz32 (6) = 1 // bit:0000 0110 所以最小有效位是1

=item bool ecb_is_pot32 (uint32_t x)

=item bool ecb_is_pot64 (uint32_t x)

=item bool ecb_is_pot (T x) [C++]

Returns true iff C<x> is a power of two or C<x == 0>.

For smaller types than C<uint32_t> you can safely use C<ecb_is_pot32>.

The overloaded C++ C<ecb_is_pot> function supports C<uint8_t>, C<uint16_t>,
C<uint32_t> and C<uint64_t> types.

返回true,如果C<x>是2的幂或C<x == 0>。

对于小于C<uint32_t>的类型，你可以安全地使用C<ecb_is_pot32>。

重载的c++ C<ecb_is_pot>函数支持C<uint8_t>， C<uint16_t>，C<uint32_t>和C<uint64_t>类型。

=item int ecb_ld32 (uint32_t x)

=item int ecb_ld64 (uint64_t x)

=item int ecb_ld64 (T x) [C++]

Returns the index of the most significant bit set in C<x>, or the number
of digits the number requires in binary (so that C<< 2**ld <= x <
2**(ld+1) >>). If C<x> is 0 the result is undefined. A common use case is
to compute the integer binary logarithm, i.e. C<floor (log2 (n))>, for
example to see how many bits a certain number requires to be encoded.

This function is similar to the "count leading zero bits" function, except
that that one returns how many zero bits are "in front" of the number (in
the given data type), while C<ecb_ld> returns how many bits the number
itself requires.

For smaller types than C<uint32_t> you can safely use C<ecb_ld32>.

The overloaded C++ C<ecb_ld> function supports C<uint8_t>, C<uint16_t>,
C<uint32_t> and C<uint64_t> types.

返回C<x>中最高bit集的索引，或者该数字需要的二进制位数(等于C<< 2**ld <= x < 2**(ld+1) >>)。
如果C<x>是0，结果是没有定义的。
一个常见的用例是计算整数二进制对数，例如C<floor (log2 (n))>，以查看某个数字需要编码多少位。

此函数类似于“count前导零位数”函数，不同之处在于该函数返回数字(在给定的数据类型中)“前面”有多少个零位数，
而C<ecb_ld>返回数字本身需要多少位。

对于小于C<uint32_t>的类型，你可以安全地使用C<ecb_ld32>。

重载的c++ C<ecb_ld>函数支持C<uint8_t>， C<uint16_t>，C<uint32_t>和C<uint64_t>类型。

=item int ecb_popcount32 (uint32_t x)

=item int ecb_popcount64 (uint64_t x)

=item int ecb_popcount (T x) [C++]

Returns the number of bits set to 1 in C<x>.

For smaller types than C<uint32_t> you can safely use C<ecb_popcount32>.

The overloaded C++ C<ecb_popcount> function supports C<uint8_t>, C<uint16_t>,
C<uint32_t> and C<uint64_t> types.

返回C<x>的bit集中为1的位数。

对于小于C<uint32_t>的类型，你可以安全地使用C<ecb_popcount32>。

重载的c++ C<ecb_popcount>函数支持uint8_t>， C<uint16_t>，uint32_t>和uint64_t>类型。

For example:

  ecb_popcount32 (7) = 3 //0000 0111
  ecb_popcount32 (255) = 8 //1111 1111

=item uint8_t  ecb_bitrev8  (uint8_t  x)

=item uint16_t ecb_bitrev16 (uint16_t x)

=item uint32_t ecb_bitrev32 (uint32_t x)

=item T ecb_bitrev (T x) [C++]

Reverses the bits in x, i.e. the MSB becomes the LSB, MSB-1 becomes LSB+1
and so on.

The overloaded C++ C<ecb_bitrev> function supports C<uint8_t>, C<uint16_t> and C<uint32_t> types.

反转x的位，即MSB变成LSB, MSB-1变成LSB+1等等。

重载的C++ C<ecb_bitrev>函数支持C<uint8_t>， C<uint16_t>和C<uint32_t>类型。

Example:

   ecb_bitrev8 (0xa7) = 0xea // 1010 0111 => 1110 1010 
   ecb_bitrev32 (0xffcc4411) = 0x882233ff // 1111 1111 1100 1100 0100 0100 0001 0001 => 1000 1000 0010 0010 0011 0011 1111 1111

   /*
    * 这两个好像颠倒的不一致
    * (0xffcc4411) = 0x882233ff
    *  1111 1111 1100 1100 0100 0100 0001 0001
    *  0001 0001 0100 0100 1100 1100 1111 1111 第一步颠倒16位字节
    *  1000 1000 0010 0010 0011 0011 1111 1111 第二步每个字节颠倒
    *   8    8    2    2    3    3    f    f
    * 所以0xa7好像有问题
    * 0xa7 = ?
    * 1010 0111
    * 0111 1010
    * 1110 0101
    *  e    5
    */

=item T ecb_bitrev (T x) [C++]

Overloaded C++ bitrev function.
重载的C++ bitrev函数,

C<T> must be one of C<uint8_t>, C<uint16_t> or C<uint32_t>.

C<T> 必须是以下类型之一: C<uint8_t>, C<uint16_t> or C<uint32_t>.

/*
 * 0x11223344 => 0x44332211
 */

=item uint32_t ecb_bswap16 (uint32_t x)

=item uint32_t ecb_bswap32 (uint32_t x)

=item uint64_t ecb_bswap64 (uint64_t x)

=item T ecb_bswap (T x)

These functions return the value of the 16-bit (32-bit, 64-bit) value
C<x> after reversing the order of bytes (0x11223344 becomes 0x44332211 in
C<ecb_bswap32>).

The overloaded C++ C<ecb_bswap> function supports C<uint8_t>, C<uint16_t>,
C<uint32_t> and C<uint64_t> types.

这些函数返回反转16位(32位、64位)之后的值.C<x>在C<ecb_bswap32>中0x11223344变为0x44332211

重载的c++ C<ecb_bswap>函数支持C<uint8_t>， C<uint16_t>，C<uint32_t>和C<uint64_t>类型。


=item uint8_t  ecb_rotl8  (uint8_t  x, unsigned int count)

=item uint16_t ecb_rotl16 (uint16_t x, unsigned int count)

=item uint32_t ecb_rotl32 (uint32_t x, unsigned int count)

=item uint64_t ecb_rotl64 (uint64_t x, unsigned int count)

=item uint8_t  ecb_rotr8  (uint8_t  x, unsigned int count)

=item uint16_t ecb_rotr16 (uint16_t x, unsigned int count)

=item uint32_t ecb_rotr32 (uint32_t x, unsigned int count)

=item uint64_t ecb_rotr64 (uint64_t x, unsigned int count)

These two families of functions return the value of C<x> after rotating
all the bits by C<count> positions to the right (C<ecb_rotr>) or left
(C<ecb_rotl>). There are no restrictions on the value C<count>, i.e. both
zero and values equal or larger than the word width work correctly. Also,
notwithstanding C<count> being unsigned, negative numbers work and shift
to the opposite direction.

Current GCC/clang versions understand these functions and usually compile
them to "optimal" code (e.g. a single C<rol> or a combination of C<shld>
on x86).

这两组函数在将所有位按C<count>位置向右(C<ecb_rotr>)或向左(C<ecb_rotl>)旋转后返回C<x>的值。
对值C<count>没有限制，即0和等于或大于字宽的值都是正确的。
同样，尽管C<count>是无符号的，但负数也能工作并向相反的方向移动。

当前的GCC/clang版本支持这些函数，并且通常将它们编译为“最优”代码(例如，在x86上一个C<rol>或一个C<shld>的组合)。

=item T ecb_rotl (T x, unsigned int count) [C++]

=item T ecb_rotr (T x, unsigned int count) [C++]

Overloaded C++ rotl/rotr functions.
重载C++的 rotl/rotr函数

C<T> must be one of C<uint8_t>, C<uint16_t>, C<uint32_t> or C<uint64_t>.
C<T> 必须是以下类型以下: C<uint8_t>, C<uint16_t>, C<uint32_t> or C<uint64_t>.

=back

=head2 BIT MIXING, HASHING

Sometimes you have an integer and want to distribute its bits well, for
example, to use it as a hash in a hashtable. A common example is pointer
values, which often only have a limited range (e.g. low and high bits are
often zero).

The following functions try to mix the bits to get a good bias-free
distribution. They were mainly made for pointers, but the underlying
integer functions are exposed as well.

As an added benefit, the functions are reversible, so if you find it
convenient to store only the hash value, you can recover the original
pointer from the hash ("unmix"), as long as your pinters are 32 or 64 bit
(if this isn't the case on your platform, drop us a note and we will add
functions for other bit widths).

The unmix functions are very slightly slower than the mix functions, so
it is equally very slightly preferable to store the original values wehen
convenient.

The underlying algorithm if subject to change, so currently these
functions are not suitable for persistent hash tables, as their result
value can change between diferent versions of libecb.

有时候你有一个整数，想把它的位分配好，例如，把它用作哈希表中的哈希。一个常见的例子是指针值，它通常只有一个有限的范围(例如，低位和高位通常为零)。

下面的函数尝试混合比特以得到一个良好的无偏置分布。它们主要是为指针而设计的，但是底层的函数也会对整数支持的很好。

另一个好处是,函数是可逆的.如果你得到这个值的是时候只是一个hash值,你可以从hash值恢复到原来的指针,此操作在32位和64位平台上都支持.
(如果发现不支持的情况,报告给我们,我们将添加其他功能位宽度)。

unmix函数要比mix函数慢一些，所以在方便的时候存储原始值也是非常可取的。

底层的算法可能会发生变化，因此目前这些函数不适合持久化哈希表，因为它们的结果值可能会在libecb的不同版本之间发生变化。

=over

=item uintptr_t ecb_ptrmix (void *ptr)

Mixes the bits of a pointer so the result is suitable for hash table
lookups. In other words, this hashes the pointer value.

混合指针的位，结果适合于哈希表查找。换句话说，这是哈希指针值。

=item uintptr_t ecb_ptrmix (T *ptr) [C++]

Overload the C<ecb_ptrmix> function to work for any pointer in C++.
重载 C<ecb_ptrmix>函数用来支持C++的中任何指针.

=item void *ecb_ptrunmix (uintptr_t v)

Unmix the hash value into the original pointer. This only works as long
as the hash value is not truncated, i.e. you used C<uintptr_t> (or
equivalent) throughout to store it.

将哈希值恢复为原来的指针。这只在哈希值没有被截断的情况下才有效，即你使用C<uintptr_t>(或等效的)来存储它。

=item T *ecb_ptrunmix<T> (uintptr_t v) [C++]

The somewhat less useful template version of C<ecb_ptrunmix> for
C++. Example:

   sometype *myptr;
   uintptr_t hash = ecb_ptrmix (myptr); //得到这个指针的hash值
   sometype *orig = ecb_ptrunmix<sometype> (hash); //从这个hash值恢复到原来的指针

=item uint32_t ecb_mix32 (uint32_t v)

=item uint64_t ecb_mix64 (uint64_t v)

Sometimes you don't have a pointer but an integer whose values are very
badly distributed. In this case you cna sue these integer versions of the
mixing function. No C++ template is provided currently.

有时你没有指针，而是一个整数，它的值分布得很糟糕。在这种情况下，你可以使用针对整数版本的相应函数。目前没有提供c++模板。

=item uint32_t ecb_unmix32 (uint32_t v)

=item uint64_t ecb_unmix64 (uint64_t v)

The reverse of the C<ecb_mix> functions - they take a mixed/hashed value
and recover the original value.

与C<ecb_mix>函数相反——它们接受mixed/hashed的值并恢复原始值。

=back

=head2 HOST ENDIANNESS CONVERSION

=over

=item uint_fast16_t ecb_be_u16_to_host (uint_fast16_t v)

=item uint_fast32_t ecb_be_u32_to_host (uint_fast32_t v)

=item uint_fast64_t ecb_be_u64_to_host (uint_fast64_t v)

=item uint_fast16_t ecb_le_u16_to_host (uint_fast16_t v)

=item uint_fast32_t ecb_le_u32_to_host (uint_fast32_t v)

=item uint_fast64_t ecb_le_u64_to_host (uint_fast64_t v)

Convert an unsigned 16, 32 or 64 bit value from big or little endian to host byte order.

The naming convention is C<ecb_>(C<be>|C<le>)C<_u>C<16|32|64>C<_to_host>,
where C<be> and C<le> stand for big endian and little endian, respectively.

将一个16、32或64位的无符号值从大字节或小字节顺序转换为主机字节顺序。

命名约定为C<ecb_>(C<be>|C<le>)C<_u>C<16|32|64>C<_to_host>，其中C<be>和C<le>分别代表大端和小端。

=item uint_fast16_t ecb_host_to_be_u16 (uint_fast16_t v)

=item uint_fast32_t ecb_host_to_be_u32 (uint_fast32_t v)

=item uint_fast64_t ecb_host_to_be_u64 (uint_fast64_t v)

=item uint_fast16_t ecb_host_to_le_u16 (uint_fast16_t v)

=item uint_fast32_t ecb_host_to_le_u32 (uint_fast32_t v)

=item uint_fast64_t ecb_host_to_le_u64 (uint_fast64_t v)

Like above, but converts I<from> host byte order to the specified
endianness.

像上面一样，但是将I<from>主机字节顺序转换为指定的字节顺序。
=back

In C++ the following additional template functions are supported:
在c++中，支持以下额外的模板函数:
=over

=item T ecb_be_to_host (T v)

=item T ecb_le_to_host (T v)

=item T ecb_host_to_be (T v)

=item T ecb_host_to_le (T v)

=back

These functions work like their C counterparts, above, but use templates,
which make them useful in generic code.

C<T> must be one of C<uint8_t>, C<uint16_t>, C<uint32_t> or C<uint64_t>
(so unlike their C counterparts, there is a version for C<uint8_t>, which
again can be useful in generic code).

这些函数的工作方式与上面的C函数类似，但使用了模板，这使得它们在泛型代码中很有用。

C<T>必须是其中一个C<uint8_t>， C<uint16_t>， C<uint32_t>或C<uint64_t>(所以不像他们的C对应，有一个版本的C<uint8_t>，这在通用代码中也可以是有用的)。

=head2 UNALIGNED LOAD/STORE

These function load or store unaligned multi-byte values.
这些函数加载或存储未对齐的多字节值。

=over

=item uint_fast16_t ecb_peek_u16_u (const void *ptr)

=item uint_fast32_t ecb_peek_u32_u (const void *ptr)

=item uint_fast64_t ecb_peek_u64_u (const void *ptr)

These functions load an unaligned, unsigned 16, 32 or 64 bit value from
memory.
这些函数从内存中加载一个unaligned, unsigned 16,32或64位的值.

=item uint_fast16_t ecb_peek_be_u16_u (const void *ptr)

=item uint_fast32_t ecb_peek_be_u32_u (const void *ptr)

=item uint_fast64_t ecb_peek_be_u64_u (const void *ptr)

=item uint_fast16_t ecb_peek_le_u16_u (const void *ptr)

=item uint_fast32_t ecb_peek_le_u32_u (const void *ptr)

=item uint_fast64_t ecb_peek_le_u64_u (const void *ptr)

Like above, but additionally convert from big endian (C<be>) or little
endian (C<le>) byte order to host byte order while doing so.

与上面类似，但在此过程中，将大端字节顺序(C<be>)或小端字节顺序(C<le>)转换为主机字节顺序。

=item ecb_poke_u16_u (void *ptr, uint16_t v)

=item ecb_poke_u32_u (void *ptr, uint32_t v)

=item ecb_poke_u64_u (void *ptr, uint64_t v)

These functions store an unaligned, unsigned 16, 32 or 64 bit value to
memory.

这些函数将一个非对齐、无符号的16、32或64位值存储到内存中。

=item ecb_poke_be_u16_u (void *ptr, uint_fast16_t v)

=item ecb_poke_be_u32_u (void *ptr, uint_fast32_t v)

=item ecb_poke_be_u64_u (void *ptr, uint_fast64_t v)

=item ecb_poke_le_u16_u (void *ptr, uint_fast16_t v)

=item ecb_poke_le_u32_u (void *ptr, uint_fast32_t v)

=item ecb_poke_le_u64_u (void *ptr, uint_fast64_t v)

Like above, but additionally convert from host byte order to big endian
(C<be>) or little endian (C<le>) byte order while doing so.

与上面类似，但在此过程中还要将主机字节顺序转换为大端字节顺序(C<be>)或小端字节顺序(C<le>)。

=back

In C++ the following additional template functions are supported:
在c++中，支持以下额外的模板函数:

=over

=item T ecb_peek<T>      (const void *ptr)

=item T ecb_peek_be<T>   (const void *ptr)

=item T ecb_peek_le<T>   (const void *ptr)

=item T ecb_peek_u<T>    (const void *ptr)

=item T ecb_peek_be_u<T> (const void *ptr)

=item T ecb_peek_le_u<T> (const void *ptr)

Similarly to their C counterparts, these functions load an unsigned 8, 16,
32 or 64 bit value from memory, with optional conversion from big/little
endian.

与C语言类似，这些函数从内存中加载无符号8、16、32或64位的值，并可选地进行大/小端字节的转换。

Since the type cannot be deduced, it has to be specified explicitly, e.g.
因为不能推断类型，所以必须显式指定它，例如。

   uint_fast16_t v = ecb_peek<uint16_t> (ptr);

C<T> must be one of C<uint8_t>, C<uint16_t>, C<uint32_t> or C<uint64_t>.

C<T> 必须是 C<uint8_t>, C<uint16_t>, C<uint32_t> or C<uint64_t>之一.

Unlike their C counterparts, these functions support 8 bit quantities
(C<uint8_t>) and also have an aligned version (without the C<_u> prefix),
all of which hopefully makes them more useful in generic code.

与它们的C对等体不同，这些函数支持8位数量(C<uint8_t>)，并且有一个对齐的版本(没有C<_u>前缀)，所有这些都希望使它们在泛型代码中更有用。

=item ecb_poke      (void *ptr, T v)

=item ecb_poke_be   (void *ptr, T v)

=item ecb_poke_le   (void *ptr, T v)

=item ecb_poke_u    (void *ptr, T v)

=item ecb_poke_be_u (void *ptr, T v)

=item ecb_poke_le_u (void *ptr, T v)

Again, similarly to their C counterparts, these functions store an
unsigned 8, 16, 32 or z64 bit value to memory, with optional conversion to
big/little endian.

同样，与C语言类似，这些函数将一个无符号8、16、32或z64位的值存储到内存中，并可选地将其转换为大/小端序。

C<T> must be one of C<uint8_t>, C<uint16_t>, C<uint32_t> or C<uint64_t>.

C<T> 必须是 C<uint8_t>, C<uint16_t>, C<uint32_t> or C<uint64_t>之一.

Unlike their C counterparts, these functions support 8 bit quantities
(C<uint8_t>) and also have an aligned version (without the C<_u> prefix),
all of which hopefully makes them more useful in generic code.

与它们的C对等体不同，这些函数支持8位数量(C<uint8_t>)，并且有一个对齐的版本(没有C<_u>前缀)，所有这些都希望使它们在泛型代码中更有用。

=back

=head2 FAST INTEGER TO STRING

Libecb defines a set of very fast integer to decimal string (or integer
to ascii, short C<i2a>) functions.  These work by converting the integer
to a fixed point representation and then successively multiplying out
the topmost digits. Unlike some other, also very fast, libraries, ecb's
algorithm should be completely branchless per digit, and does not rely on
the presence of special cpu functions (such as clz).

There is a high level API that takes an C<int32_t>, C<uint32_t>,
C<int64_t> or C<uint64_t> as argument, and a low-level API, which is
harder to use but supports slightly more formatting options.

Libecb定义了一组非常快的整数转换为十进制字符串(或整数到ascii，short C<i2a>)函数。
它们的工作原理是将整数转换为定点表示，然后依次将最上面的数字乘出来。
与其他一些同样非常快的库不同，ecb的算法应该是完全位无关的，并且不依赖于特殊的cpu函数(如clz)的存在。

有一个高级API，它接受一个C<int32_t>， C<uint32_t>， C<int64_t>或C<uint64_t>作为参数，
和一个低级API，它更难使用，但支持稍微更多的格式化选项

=head3 HIGH LEVEL API

The high level API consists of four functions, one each for C<int32_t>,
C<uint32_t>, C<int64_t> and C<uint64_t>:

高级API由四个函数组成，分别为C<int32_t>， C<uint32_t>， C<int64_t>和C<uint64_t>:

Example:

   char buf[ECB_I2A_MAX_DIGITS + 1];
   char *end = ecb_i2a_i32 (buf, 17262);
   *end = 0;
   // buf now contains "17262"

=over

=item ECB_I2A_I32_DIGITS (=11)

=item char *ecb_i2a_u32 (char *ptr, uint32_t value)

Takes an C<uint32_t> I<value> and formats it as a decimal number starting
at I<ptr>, using at most C<ECB_I2A_I32_DIGITS> characters. Returns a
pointer to just after the generated string, where you would normally put
the terminating C<0> character. This function outputs the minimum number
of digits.

使用C<uint32_t> I<value>并将其格式化为从I<ptr>开始的十进制数，最多使用C<ECB_I2A_I32_DIGITS>个字符。
返回指向生成的字符串后一位指针，通常将C<0>字符作为结束符。这个函数输出最小位数。

=item ECB_I2A_U32_DIGITS (=10)

=item char *ecb_i2a_i32 (char *ptr, int32_t value)

Same as C<ecb_i2a_u32>, but formats a C<int32_t> value, including a minus
sign if needed.

类似于C<ecb_i2a_u32>,但是参数支持C<int32_t>类型的值,如果需要,也支持负数的"-".

=item ECB_I2A_I64_DIGITS (=20)

=item char *ecb_i2a_u64 (char *ptr, uint64_t value)

=item ECB_I2A_U64_DIGITS (=21)

=item char *ecb_i2a_i64 (char *ptr, int64_t value)

Similar to their 32 bit counterparts, these take a 64 bit argument.

与32位的类似，这些参数为64位。

=item ECB_I2A_MAX_DIGITS (=21)

Instead of using a type specific length macro, you can just use
C<ECB_I2A_MAX_DIGITS>, which is good enough for any C<ecb_i2a> function.

不使用特定于类型长度的宏，您可以只使用C<ECB_I2A_MAX_DIGITS>，这对于任何C<ecb_i2a>函数都足够好了。

=back

=head3 LOW-LEVEL API

The functions above use a number of low-level APIs which have some strict
limitations, but can be used as building blocks (studying C<ecb_i2a_i32>
and related functions is recommended).

上面的函数使用了一些低级api，这些api有一些严格的限制，
但可以用作构建块(建议学习C<ecb_i2a_i32>和相关函数)。

There are three families of functions: functions that convert a number
to a fixed number of digits with leading zeroes (C<ecb_i2a_0N>, C<0>
for "leading zeroes"), functions that generate up to N digits, skipping
leading zeroes (C<_N>), and functions that can generate more digits, but
the leading digit has limited range (C<_xN>).

这里有3个函数簇:
  1. 数字转换为固定数量的数字与补零(C<ecb_i2a_0N>, C<0>前置补零),
  2. 函数生成到N位,前置不不零(C<_N>)
  3. 函数可以产生更多的数字,但领先的数字范围有限(C<_xN>)。

None of the functions deal with negative numbers.

没有一个函数处理负数。

Example: convert an IP address in an u32 into dotted-quad:

   uint32_t ip = 0x0a000164; // 10.0.1.100
   char ips[3 * 4 + 3 + 1];
   char *ptr = ips;
   ptr = ecb_i2a_3 (ptr,  ip >> 24        ); *ptr++ = '.';
   ptr = ecb_i2a_3 (ptr, (ip >> 16) & 0xff); *ptr++ = '.';
   ptr = ecb_i2a_3 (ptr, (ip >>  8) & 0xff); *ptr++ = '.';
   ptr = ecb_i2a_3 (ptr,  ip        & 0xff); *ptr++ = 0;
   printf ("ip: %s\n", ips); // prints "ip: 10.0.1.100"

=over

=item char *ecb_i2a_02  (char *ptr, uint32_t value) // 32 bit

=item char *ecb_i2a_03  (char *ptr, uint32_t value) // 32 bit

=item char *ecb_i2a_04  (char *ptr, uint32_t value) // 32 bit

=item char *ecb_i2a_05  (char *ptr, uint32_t value) // 64 bit

=item char *ecb_i2a_06  (char *ptr, uint32_t value) // 64 bit

=item char *ecb_i2a_07  (char *ptr, uint32_t value) // 64 bit

=item char *ecb_i2a_08  (char *ptr, uint32_t value) // 64 bit

=item char *ecb_i2a_09  (char *ptr, uint32_t value) // 64 bit

The C<< ecb_i2a_0I<N> >> functions take an unsigned I<value> and convert
them to exactly I<N> digits, returning a pointer to the first character
after the digits. The I<value> must be in range. The functions marked with
I<32 bit> do their calculations internally in 32 bit, the ones marked with
I<64 bit> internally use 64 bit integers, which might be slow on 32 bit
architectures (the high level API decides on 32 vs. 64 bit versions using
C<ECB_64BIT_NATIVE>).

C<< ecb_i2a_0I<N> >>函数接受一个无符号的I<value>并将其转换为适当的I<N>位的数字，
返回一个指向数字后面第一个字符的指针。I<value>必须在一个范围内。
标记为I<32 bit>的函数在内部以32位进行计算，标记为I<64 bit>的函数在内部使用64位整数，
这在32位体系结构上可能会很慢(高级API使用C<ECB_64BIT_NATIVE>决定32位和64位版本)。

=item char *ecb_i2a_2   (char *ptr, uint32_t value) // 32 bit

=item char *ecb_i2a_3   (char *ptr, uint32_t value) // 32 bit

=item char *ecb_i2a_4   (char *ptr, uint32_t value) // 32 bit

=item char *ecb_i2a_5   (char *ptr, uint32_t value) // 64 bit

=item char *ecb_i2a_6   (char *ptr, uint32_t value) // 64 bit

=item char *ecb_i2a_7   (char *ptr, uint32_t value) // 64 bit

=item char *ecb_i2a_8   (char *ptr, uint32_t value) // 64 bit

=item char *ecb_i2a_9   (char *ptr, uint32_t value) // 64 bit

Similarly, the C<< ecb_i2a_I<N> >> functions take an unsigned I<value>
and convert them to at most I<N> digits, suppressing leading zeroes, and
returning a pointer to the first character after the digits.

类似地，C<< ecb_i2a_I<N> >>函数接受一个无符号的I<value>并将其转换为最多I<N>位数字，
不包含前导零，并返回一个指向数字后第一个字符的指针。

=item ECB_I2A_MAX_X5 (=59074)

=item char *ecb_i2a_x5  (char *ptr, uint32_t value) // 32 bit

=item ECB_I2A_MAX_X10 (=2932500665)

=item char *ecb_i2a_x10 (char *ptr, uint32_t value) // 64 bit

The C<< ecb_i2a_xI<N> >> functions are similar to the C<< ecb_i2a_I<N> >>
functions, but they can generate one digit more, as long as the number
is within range, which is given by the symbols C<ECB_I2A_MAX_X5> (almost
16 bit range) and C<ECB_I2A_MAX_X10> (a bit more than 31 bit range),
respectively.

C<< ecb_i2a_xI<N> >>功能类似于C<< ecb_i2a_I<N> >>功能.只要数量范围内,它们就可以生成一个数字.
这是由符号C<ECB_I2A_MAX_X5>(差不多16位范围)和C<ECB_I2A_MAX_X10>(31位多一点范围)。

For example, the digit part of a 32 bit signed integer just fits into the
C<ECB_I2A_MAX_X10> range, so while C<ecb_i2a_x10> cannot convert a 10
digit number, it can convert all 32 bit signed numbers. Sadly, it's not
good enough for 32 bit unsigned numbers.

例如，32位有符号整数的数字部分刚好适合C<ECB_I2A_MAX_X10>范围，
因此尽管C<ecb_i2a_x10>不能转换十进制数字，但它可以转换所有32位有符号数字。
遗憾的是，对于32位无符号数来说，它还不够好。

=back

=head2 FLOATING POINT FIDDLING

=over

=item ECB_INFINITY [-UECB_NO_LIBM]

Evaluates to positive infinity if supported by the platform, otherwise to
a truly huge number.

测试平台是否支持正无穷叔，不支持的话,则为一个真正巨大的数字。

=item ECB_NAN [-UECB_NO_LIBM]

Evaluates to a quiet NAN if supported by the platform, otherwise to
C<ECB_INFINITY>.

检测平台是否支持NAN,如果支持的话,直接就是NAN,反之为C<ECB_INFINITY>.

=item float ecb_ldexpf (float x, int exp) [-UECB_NO_LIBM]

Same as C<ldexpf>, but always available.

与C<ldexpf>相同，但始终可用。

=item uint32_t ecb_float_to_binary16  (float  x) [-UECB_NO_LIBM]

=item uint32_t ecb_float_to_binary32  (float  x) [-UECB_NO_LIBM]

=item uint64_t ecb_double_to_binary64 (double x) [-UECB_NO_LIBM]

These functions each take an argument in the native C<float> or C<double>
type and return the IEEE 754 bit representation of it (binary16/half,
binary32/single or binary64/double precision).

这些函数都接受原生C<float>或C<double>类型的实参，
并返回其IEEE 754位的表示(binary16/half、binary32/single或binary64/double precision)。

The bit representation is just as IEEE 754 defines it, i.e. the sign bit
will be the most significant bit, followed by exponent and mantissa.

位的表示就像IEEE 754定义的那样，即符号位将是最重要的位，然后是指数和尾数。

This function should work even when the native floating point format isn't
IEEE compliant, of course at a speed and code size penalty, and of course
also within reasonable limits (it tries to convert NaNs, infinities and
denormals, but will likely convert negative zero to positive zero).

即使本机浮点格式不符合IEEE标准，这个函数也可以工作，当然速度和代码大小会受到影响，
不过这也在合理的限制内(它试图转换nan、无穷大和非法线，但可能会将负0转换为正0)。

On all modern platforms (where C<ECB_STDFP> is true), the compiler should
be able to completely optimise away the 32 and 64 bit functions.

在所有现代平台上(C<ECB_STDFP>为真)，编译器应该能够完全优化掉32位和64位函数。

These functions can be helpful when serialising floats to the network - you
can serialise the return value like a normal uint16_t/uint32_t/uint64_t.

这些函数在序列化浮点数到网络时很有用——你可以像一个正常的uint16_t/uint32_t/uint64_t一样序列化返回值，

Another use for these functions is to manipulate floating point values
directly.

这些函数的另一个用途是直接操作浮点值。

Silly example: toggle the sign bit of a float.
不太好的例子:切换浮点数的符号位。

   /* On gcc-4.7 on amd64, */
   /* this results in a single add instruction to toggle the bit, and 4 extra */
   /* instructions to move the float value to an integer register and back. */
   /*这将导致一个添加指令来切换位，和4个额外的指令来移动浮点值到一个整数寄存器并返回。*／

   x = ecb_binary32_to_float (ecb_float_to_binary32 (x) ^ 0x80000000U)

=item float  ecb_binary16_to_float  (uint16_t x) [-UECB_NO_LIBM]

=item float  ecb_binary32_to_float  (uint32_t x) [-UECB_NO_LIBM]

=item double ecb_binary64_to_double (uint64_t x) [-UECB_NO_LIBM]

The reverse operation of the previous function - takes the bit
representation of an IEEE binary16, binary32 or binary64 number (half,
single or double precision) and converts it to the native C<float> or
C<double> format.

前一个函数的反向操作-将IEEE binary16、binary32或binary64的数字(half、single或double precision)的位表示转换为原生C<float>或C<double>格式。

This function should work even when the native floating point format isn't
IEEE compliant, of course at a speed and code size penalty, and of course
also within reasonable limits (it tries to convert normals and denormals,
and might be lucky for infinities, and with extraordinary luck, also for
negative zero).

这个函数应该即使本机IEEE浮点格式不兼容问题也不大,当然速度和代码大小会变差,
但也在合理的范围内(它试图将法线和denormals,和可能幸运无穷大,和非凡的运气,也为负0)。

On all modern platforms (where C<ECB_STDFP> is true), the compiler should
be able to optimise away this function completely.

在所有现代平台上(C<ECB_STDFP>为真)，编译器应该能够完全优化这个函数。

=item uint16_t ecb_binary32_to_binary16 (uint32_t x)

=item uint32_t ecb_binary16_to_binary32 (uint16_t x)

Convert a IEEE binary32/single precision to binary16/half format, and vice
versa, handling all details (round-to-nearest-even, subnormals, infinity
and NaNs) correctly.

将IEEE binary32/单精度转换为binary16/半格式.
反之亦然，并且正确处理所有细节(从最接近偶数到最接近偶数、次法线、无穷大和nan)。

These are functions are available under C<-DECB_NO_LIBM>, since
they do not rely on the platform floating point format. The
C<ecb_float_to_binary16> and C<ecb_binary16_to_float> functions are
usually what you want.

这些函数可以在C<-DECB_NO_LIBM>下使用，因为它们不依赖于平台浮点格式。
C<ecb_float_to_binary16>和C<ecb_binary16_to_float>函数通常是你想要的。

=back

=head2 ARITHMETIC

=over

=item x = ecb_mod (m, n)

Returns C<m> modulo C<n>, which is the same as the positive remainder
of the division operation between C<m> and C<n>, using floored
division. Unlike the C remainder operator C<%>, this function ensures that
the return value is always positive and that the two numbers I<m> and
I<m' = m + i * n> result in the same value modulo I<n> - in other words,
C<ecb_mod> implements the mathematical modulo operation, which is missing
in the language.

返回C<m>对C<n>取模，与C<m>和C<n>之间的除法运算的正余数相同，使用底数除法。
不像C的运算符C<%>,这个函数确保返回值总是正的.
两个数字I<m>和I<m' = m + I * n>的结果总是与I<n>的取模是相同的——换句话说,C<ecb_mod>实现数学模操作,这是语言中没有的。

C<n> must be strictly positive (i.e. C<< >= 1 >>), while C<m> must be
negatable, that is, both C<m> and C<-m> must be representable in its
type (this typically excludes the minimum signed integer value, the same
limitation as for C</> and C<%> in C).

C<n>必须是严格的正数(即C<< >= 1 >>)，而C<m>必须是可负的.
也就是说，C<m>和C<-m>必须在其类型中是可表示的(这通常排除了最小有符号整数值，与C中C</>和C<%>的限制相同)。

Current GCC/clang versions compile this into an efficient branchless
sequence on almost all CPUs.

当前的GCC/clang版本几乎在所有的cpu上都将其编译成一个高效的无分支序列。

For example, when you want to rotate forward through the members of an
array for increasing C<m> (which might be negative), then you should use
C<ecb_mod>, as the C<%> operator might give either negative results, or
change direction for negative values:

例如，当你想遍历一个数组的成员C<m>(可能是负的)，那么你应该使用C<ecb_mod>，因为C<%>运算符可能会给出负的结果，或者为负值改变方向:

   for (m = -100; m <= 100; ++m)
     int elem = myarray [ecb_mod (m, ecb_array_length (myarray))];

=item x = ecb_div_rd (val, div)

=item x = ecb_div_ru (val, div)

Returns C<val> divided by C<div> rounded down or up, respectively.
C<val> and C<div> must have integer types and C<div> must be strictly
positive. Note that these functions are implemented with macros in C
and with function templates in C++.

返回C<val>除以C<div>后向下四舍五入或向上四舍五入的值。
C<val>和C<div>必须是整数类型，C<div>必须是严格正的。
注意，这些函数是用C语言的宏和c++的函数模板实现的。

=back

=head2 UTILITY

=over

=item element_count = ecb_array_length (name)

Returns the number of elements in the array C<name>. For example:

返回数组C<name>中的元素个数。例如:

  int primes[] = { 2, 3, 5, 7, 11 };
  int sum = 0;

  for (i = 0; i < ecb_array_length (primes); i++)
    sum += primes [i];

=back

=head2 SYMBOLS GOVERNING COMPILATION OF ECB.H ITSELF

These symbols need to be defined before including F<ecb.h> the first time.

在第一次包含F<ecb.h>之前，需要定义这些符号。

=over

=item ECB_NO_THREADS

If F<ecb.h> is never used from multiple threads, then this symbol can
be defined, in which case memory fences (and similar constructs) are
completely removed, leading to more efficient code and fewer dependencies.

如果F<ecb.h>从来没有在多线程环境中使用，那么这个符号可以被定义，
在这种情况下，内存栅栏(和类似的结构)被完全移除，导致更高效的代码和更少的依赖。

Setting this symbol to a true value implies C<ECB_NO_SMP>.

将该符号设置为真值意味着C<ECB_NO_SMP>。

=item ECB_NO_SMP

The weaker version of C<ECB_NO_THREADS> - if F<ecb.h> is used from
multiple threads, but never concurrently (e.g. if the system the program
runs on has only a single CPU with a single core, no hyperthreading and so
on), then this symbol can be defined, leading to more efficient code and
fewer dependencies.

较弱的版本的C<ECB_NO_THREADS>,如果F<ecb.h>在多线程中使用,
但从未并行(例如,如果系统程序只有一个CPU上运行一个核心,没有超线程等等),
那么这个符号可以被定义,导致更高效的代码和更少的依赖关系。

=item ECB_NO_LIBM

When defined to C<1>, do not export any functions that might introduce
dependencies on the math library (usually called F<-lm>) - these are
marked with [-UECB_NO_LIBM].

当定义为C<1>时，不要导出任何可能引入依赖于数学库的函数(通常称为F<-lm>)——这些函数被标记为[-UECB_NO_LIBM]。

=back

=head1 UNDOCUMENTED FUNCTIONALITY

F<ecb.h> is full of undocumented functionality as well, some of which is
intended to be internal-use only, some of which we forgot to document, and
some of which we hide because we are not sure we will keep the interface
stable.

F<ecb.h>还有很多没有文档化的功能，其中一些仅用于内部使用，一些我们"忘记"了文档化，
一些我们隐藏了，因为我们不确定是否会保持接口稳定。

While you are welcome to rummage around and use whatever you find useful
(we don't want to stop you), keep in mind that we will change undocumented
functionality in incompatible ways without thinking twice, while we are
considerably more conservative with documented things.

虽然欢迎您四处翻找并使用任何您认为有用的东西(我们不想阻止您).
但请记住，我们将毫不犹豫地以不兼容的方式更改未文档化的功能，而我们对已文档化的东西要保守得多。

=head1 AUTHORS

C<libecb> is designed and maintained by:

   Emanuele Giaquinta <e.giaquinta@glauco.it>
   Marc Alexander Lehmann <schmorp@schmorp.de>
